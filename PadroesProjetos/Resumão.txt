Abstract Factory
	As classes Abstract Factory são frequentemente implementadas com Factory Methods
(criados por conta da herança), mas podem sê-lo por meio do Prototype (sua criação é
por meio de delegação).

Builder
	O código da construção é isolado do código da representação. Ambos são facilmente substituídos sem afetar o
outro;
	Padrões relacionados: Bridge; Observer; State.
	
	
Factory Method
	Muitas vezes, os projetos começam usando o Factory Method (menos complicado e mais personalizável, no
qual as subclasses proliferam) até evoluírem para Abstract Factory, Prototype ou Builder (mais 􀂧exível e mais
complexo) à medida que o designer descobrir em qual ponto é necessário haver mais 􀂧exibilidade.
	Padrões relacionados: Strategy; Visitor.
	
Singleton
	O Abstract Factory, o Builder e o Prototype podem usar o Singleton em suas implementações
	Padrões relacionados: Abstract Factory, Flyweight, Template
	
Adapter
	Padrões relacionados: Facade; Proxy.
	
Bridge
	Os padrões Adapter, Facade, Composite e Bridge atuam principalmente na adaptação de 
	interfaces. O Adapter faz as coisas funcionarem depois de serem projetadas; o Bridge, 
	com que funcionem antes disso.
	
	A estrutura de State e Bridge é idêntica, embora este admita hierarquias de múltiplas 
	classes e aquele, apenas uma.
	
Composite	
	O Flyweight é frequentemente combinado com o Composite para implementar nós de folhas 
	compartilhados. Afinal, o Composite pode ser tratado atomicamente, assim como uma folha.

	Já o padrão Visitor pode aplicar uma operação sobre um Composite, que pode ser percorrido 
	com Iterator. O Composite também pode usar Chain of Responsibility para permitir que os 
	componentes acessem propriedades globais por meio de seus pais.
	
	manipular coleção hierárquica de objetos de forma uniforme?

	Padrões relacionados:

	Decorator;
	Chain of Responsibility;
	Iterator.
	
Decorator
	Desejarmos incluir ou excluir responsabilidades de objetos individuais dinamicamente de forma transparente;
	Quisermos evitar o crescimento expressivo de subclasses para prover todas as combinações de responsabilidades entre os objetos;
	Necessitarmos acrescentar responsabilidades a um objeto dinamicamente;
	Desejarmos fornecer uma alternativa ao uso de subclasses para estender a funcionalidade de uma classe.
	
	O Decorator tem a função de adicionar dinamicamente alterações no comportamento dos objetos. Para isso, ele utiliza composição em vez de herança.
	
	O Decorator tem um ponto negativo: ele pode criar muitas classes pequenas, tornando o projeto mais difícil de ser entendido.
	
	Padrões relacionados:
	Composite;
	Chain of Responsibility;
	Interpreter.
	
Facade
	O Facade define uma nova interface, enquanto o Adapter usa uma antiga. Lembre-se de que o Adapter faz 
	duas interfaces existentes trabalharem juntas em vez de definir uma inteiramente nova;
	
	Enquanto o Flyweight mostra como criar muitos pequenos objetos, o Facade demonstra como fazer um único 
	objeto representar um subsistema inteiro;
	
	O Abstract Factory pode ser usado como uma alternativa ao Facade para ocultar classes específicas da plataforma;
	
	Tanto o Adapter quanto o Facade são invólucros, embora sejam de diferentes tipos. A intenção deste é 
	produzir uma interface mais simples; a daquele, redesenhar uma existente;
	
	Enquanto o Facade rotineiramente envolve vários objetos, o Adapter o faz com apenas um;
	
	O Facade poderia ser a interface de um único objeto complexo; o Adapter, de vários objetos legados.
	
	Padrões relacionados:
		Adapter
		Proxy
		
Flyweight [peso mosca]
	magine que existe um grupo de objetos que serão compartilhados juntos, por exemplo, uma sequência de 
	objetos do cenário. Nesta situação, existe uma combinação com outro padrão, o Composite. Com ele é 
	possível agrupar um conjuntos de objetos Flyweight que serão compartilhados juntos.
	
	O Flyweight é frequentemente combinado com o Composite para implementar nós de folhas compartilhados.
	
	
	
	
	
	
	
	



	
	
	
